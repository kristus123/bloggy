To have taken a step without knowing where to go.

One of the juniors have been working on a task in a codebase which is still unfamiliar to him and even the language is new to him.
The implemented solution has also come at the cost of having to spend time debugging.
There has been a few reasons (as i have observed passively) which has driven him to an unsteady path

1. Doing too much at once
2. Narrow focus (Not looking at the bigger picture)
3. Not taking one step at a time
4. Not taking it slow
 
### Those reasons are not the biggest reason he failed

the biggest reason he failed was because [I failed to guide him properly](/content/blogs/expressing-your-thoughts-effeciently).


One might think that by doing nothing, you will never complete anything,
so you have to do something or else you will never progress.

But what if you complete everything while your mind is in a state of disorder?
You are walking blindly, hoping you are going the right direction.

The solution will work? Who knows, you won't have any idea whether it works or not because you have not been solving the task,
you have only gambled that it will work. It is only when you test it that you find bugs and errors that will eat your time and make you consider selling hot-dogs for a living instead.

Taking one step at a time is nothing new, and is only another way of saying
**<span style="color:red">red</span>-<span style="color:green">green</span>-<span style="color:navy">refactor</span>**
but in a much wider sense.

Taking one step at a time is applied everywhere, even before you start `typing the code`.

## Doing too much at once
Why are you doing too much at once ? What would happen if you took one step at a time ?
It's not possible to do too much at once if every step you take is a well placed step.

Then how can you avoid taking a misstep ? In software you can not predict the future,
which might make it feel like you just have to take a blind step at times. 

If you are standing in a forest where you can't even see your feet, you will have to feel your way through the forest.
You slowly take your foot out and place it on the ground. When you know for sure you are standing on steady ground,
only then will you be confident in moving the other foot, taking the next step.

## Taking a step back (in order to move forward)
People often experience love at first sight with the code they write for a new solution. Maybe a few days passes,
and the code no longer fits in the future requirements. It can be hard to let go, but the right thing to do will be to
take a step back and prepare to go forward yet again.

So have we now gone 1 step forward and slided 2 steps back ?
No, we have not. By reverting back to the original solution we have simply put our feet back on stable ground,
while looking for a new place where you can plant your first of many steps forward.
We now have more information than we did originally, which will be of much value when we keep moving forward.

When working like this it is important to get fast feedback on whether you are standing on solid ground or not.
Activites like Unit tests or 'test-as-you-go' will give you this feedback.

If you spend 2 days working on something, and at the last hour of your workday you decide to test it,
you will absolutely meet a giant brick wall that will slap you in the face.

The reason TDD is a time saver is because it helps you avoid getting slapped in the face by a brick wall.

When you encounter a problem, you know exactly what step caused the error
which reduces the amount of time needing to diagnose where the error lies.

(You don't need TDD for this, but having a test suite definitely makes you move more confidently)

